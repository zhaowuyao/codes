package test;

import java.util.Arrays;
import java.util.Scanner;

//题目描述
//给定一个正整数，我们可以定义出下面的公式:
//N=a[1]+a[2]+a[3]+…+a[m];
//a[i]>0,1<=m<=N;
//对于一个正整数，求解满足上面公式的所有算式组合，如，对于整数 4 :
//
//4 = 4;
//4 = 3 + 1;
//4 = 2 + 2;
//4 = 2 + 1 + 1;
//4 = 1 + 1 + 1 + 1;
//所以上面的结果是 5 。
//注意：对于 “4 = 3 + 1” 和 “4 = 1 + 3” ，这两处算式实际上是同一个组合!
//
//解答要求
//时间限制：1000ms, 内存限制：64MB
//输入
//每个用例中，会有多行输入，每行输入一个正整数，表示要求解的正整数N(1 ≤ N ≤ 120) 。
//
//输出
//对输入中的每个整数求解答案，并输出一行(回车换行);
//
//样例
//输入样例 1 复制
//
//4
//10
//20
//输出样例 1
//
//5
//42
//627




///*****************************************************************************
//Description: 
//    n=m1+m2+m3+....+mi;（其中mi为正整数，并且1<=mi<=n），则{m1,m2,m3,....,mi}为n的一个划分。
//    如果{m1,m2,m3,....,mi}中的最大值不超过m，即max{m1,m2,m3,....,mi} <= m，则称它属于n的一个m划分。
//    这里我们记n的m划分的个数为f(n,m)；
//        根据n和m的关系，考虑下面几种情况：
//    （1）当n=1时，不论m的值为多少（m>0），只有一种划分，即{1}；
//    （2）当m=1时，不论n的值为多少（n>0），只有一种划分，即{1,1,....1,1,1}；
//    （3）当n=m时，根据划分中是否包含n，可以分为两种情况：
//    划分中包含n的情况，只有一个，即{n}；
//    划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有（n-1）划分；
//      因此，f(n,n) = 1 + f(n, n - 1)。
//    （4）当n<m时，由于划分中不可能出现负数，因此就相当于f(n,n)；
//    （5）当n>m时，根据划分中是否包含m，可以分为两种情况：
//    划分中包含m的情况，即{m,{x1,x2,x3,...,xi}}，其中{x1,x2,x3,...,xi}的和为n-m，
//    n-m的划分最大值不能超过m,因为m>max{x1,x2,x3,...,xi} 因此是（n-m）的m划分，因此这种划分个数为f(n-m, m)；
//    划分中不包含m的情况，则划分中所有值都比m小，即n的（m-1）划分，个数为f(n, m - 1)；
//     因此，f(n,m) = f(n - m,m) + f(n, m - 1)。
//*****************************************************************************/
public class ZhengShuChaiFen {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc=new Scanner(System.in);
		while(sc.hasNext()){
			int n=sc.nextInt();
			int[][] dp=new int[n+1][n+1];
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){
					if(i<j){
						dp[i][j]=dp[i][i];
					}else if(i==j){
						dp[i][j]=dp[i][j-1]+1;
					}else if(i>j){
						dp[i][j]=dp[i-j][j]+dp[i][j-1];
					}
				}
			}
			System.out.println(dp[n][n]);
		}
	}

}
